#include "dot_output.h"
#include "version.h"

#include <iostream>


void dot_output::gen()
{
std::clog << __func__ << "()called.\n";
    out << "// This file is automatically generated by scxmlcc (version " << version() << ")\n"
        << "// For more information, see http://scxmlcc.org\n"
        << "// View result online: https://dreampuf.github.io/GraphvizOnline/\n"
        << '\n';

    out << "digraph finite_state_machine {\n"
        << "\tnode [shape = Mrecord];\n"
        << "\tcompound=true;\n"
        << "\tsize=\"8,5;\"\n";

    gen_states();

    out << "}\n";
}

void dot_output::gen_states()
{
std::clog << __func__ << "()called.\n";
    const scxml_parser::plist<scxml_parser::state>& states = sc.sc().states;

    // states
    for(const auto& state : states)
    {
        gen_state(*state, out);
    }

    // transitions must be created after all states are in our "created" list.
    for(const auto& state : states)
    {
        for(const auto& transition : state->transitions)
        {
            gen_transition(*state, *transition, out);
        }
    }

}

void dot_output::gen_state(const scxml_parser::state &state, std::ostream& os)
{
std::clog << __func__ << "()called.\n";
    //out << "// State " << state.id << " Type = " << state.type << '\n';
    if(stateAdded(state.id))
    {
        return;
    }
    if(hasChildren(state))
    {
        gen_state_with_children(state, os);
        return;
    }

    if(! state.type)
    {
        gen_state_simple(state, os);
    }else
    {
        if(*state.type == "final")
        {
            gen_state_final(state, os);
            return;
        }
// #error and now? Unknown state type
    }
    addState(state.id);
}

void dot_output::gen_state_with_children(const scxml_parser::state &state, std::ostream &os)
{
std::clog << __func__ << "()called.\n";

    // Create a cluster
    int clusterNumber = currentClusterNumber++;
    os << "subgraph cluster" << clusterNumber << " {\n"
        << "style=\"rounded\";\n"
        << "label=<\n"
        << "<table border='0' cellborder='0' style='rounded'>\n"
        << "\t<tr><td colspan='3'><b>" << state.id << "</b></td></tr>\n";

    if(! state.entry_actions.empty())
    {
        os << "<tr><td rowspan='" << state.entry_actions.size() << "'>entry:</td>";
        gen_actions(state.entry_actions, os);
        os << "</tr>\n";
    }

    if(! state.exit_actions.empty())
    {
        os << "<tr><td rowspan='" << state.exit_actions.size() << "'>exit:</td>";
        gen_actions(state.exit_actions, os);
        os << "</tr>\n";
    }

    os << "</table>\n"
       << ">;\n";

    for(const auto& stateName : getChildrenNames(state))
    {
        std::ostringstream subOss;
        gen_state(getState(stateName), subOss);
        os << subOss.str();
    }
    os << "};\n";
    addState(state.id, clusterNumber);
}

void dot_output::gen_state_simple(const scxml_parser::state &state, std::ostream &os)
{
std::clog << __func__ << "()called.\n";

    os << '\t' << state.id << "[\n"
        << "\t\tlabel=<\n"
        << "\t\t\t<table border='0' cellborder='0' style='rounded'>\n"
        << "\t\t\t\t<tr><td colspan='3'><b>" << state.id << "</b></td></tr>\n";

    if(! state.entry_actions.empty())
    {
        os << "<tr><td rowspan='" << state.entry_actions.size() << "'>entry:</td>";
        gen_actions(state.entry_actions, os);
        os << "</tr>\n";
    }

    if(! state.exit_actions.empty())
    {
        os << "<tr><td rowspan='" << state.exit_actions.size() << "'>exit:</td>";
        gen_actions(state.exit_actions, os);
        os << "</tr>\n";
    }
    os << "\t\t\t</table>\n"
        << "\t\t>]\n";
    addState(state.id);
}

void dot_output::gen_state_final(const scxml_parser::state &state, std::ostream &os)
{
std::clog << __func__ << "()called.\n";
    os << '\t' << state.id
        << "[label=\"\","
        << "shape=doublecircle,"
        << "style=filled,"
        << "fixedsize=true,"
        << "fillcolor=black,"
        << "width=0.2];"
        << " // Final\n";
    addState(state.id);
}

void dot_output::gen_transition(const scxml_parser::state& sourceState,
                                const scxml_parser::transition& transition,
                                std::ostream& os)
{
std::clog << __func__ << "()called.\n";
    scxml_parser::slist targets = transition.target;
    if(targets.empty())
    {
        targets.push_back(sourceState.id);
    }
    for(const auto& target : targets)
    {
        std::string events;
        for(const auto& event : transition.event)
        {
            events += event + ",";
        }
        if(!events.empty())
        {
            events.pop_back();
        }


        const scxml_parser::state& targetState = getState(target);
        const scxml_parser::state& targetLeaf = getFirstLeafState(targetState);
        const scxml_parser::state& sourceLeaf = getFirstLeafState(sourceState);

        os << sourceLeaf.id << "->" << targetLeaf.id << '[';
        // draw arrow connections to the first child because arrow to cluster is not possible
        if(sourceState.id != sourceLeaf.id)
        {
            os << "ltail=cluster" << getStateClusterNumber(sourceState.id) << ',';
        }
        if(targetState.id != targetLeaf.id)
        {
          os << "lhead=cluster" << getStateClusterNumber(targetState.id) << ',';
        }

        if(transition.type && *transition.type == "internal")
        {
            out << "style=\"dashed\",";
        }

        os << "label=<\n"
            << "\t\t\t<table border='0'>\n"
            << "\t\t\t\t<tr><td colspan='2'>" << events;
        if(transition.condition)
        {
          os << " ["<< transition.condition << "]";
        }
        os << "</td></tr>\n";
        if(! transition.actions.empty())
        {
            os << "<tr><td rowspan='" << transition.actions.size() << "'>onTransition:</td>";
            gen_actions(transition.actions, os);
            os << "</tr>\n";
        }

        os << "\t\t\t</table>\n"
            << "\t\t\n";
        os << "\t>];\n";
    }
}

void dot_output::gen_actions(const scxml_parser::plist<scxml_parser::action>& actions,
                             std::ostream& os)
{
std::clog << __func__ << "()called.\n";
    bool firstActionAttr = true;
    for(auto& action : actions)
    {
std::clog << __func__ << "()called, first = " << firstActionAttr << '\n';
        if(! firstActionAttr)
        {
            os << "</tr><tr>";
        }
        firstActionAttr = false;

        // type = script,...
        os << "<td>" << action->type << ": </td>"
            << "<td>";
        for(auto& actionPair : action->attr)
        {
            os << "TODO";
        }
        os << "</td>";
    }
}

bool dot_output::stateAdded(const std::string& stateName) const
{
    return addedStateNames.find(stateName) != addedStateNames.end();
}

bool dot_output::addState(const std::string& stateName, int clusterNumber)
{
    addedStateNames[stateName] = clusterNumber;
}

int dot_output::getStateClusterNumber(const std::string& stateName) const
{
    if(! stateAdded(stateName))
    {
        return 0;
    }
    return addedStateNames.at(stateName);
}

bool dot_output::hasChildren(const scxml_parser::state &state) const
{
    for(const auto& statePtr : sc.sc().states)
    {
        if(statePtr->parent)
        {
            if(statePtr->parent->id == state.id)
            {
                return true;
            }
        }
    }
    return false;
}

std::vector<std::string> dot_output::getChildrenNames(const scxml_parser::state &state) const
{
    std::vector<std::string> ret;
    for(const auto& currStatePtr : sc.sc().states)
    {
        if(currStatePtr->parent)
        {
            if(currStatePtr->parent->id == state.id)
            {
                ret.push_back(currStatePtr->id);
            }
        }
    }
    return ret;
}

const scxml_parser::state& dot_output::getState(const std::string &stateName)
{
    for(const auto& currStatePtr : sc.sc().states)
    {
        if(currStatePtr->id == stateName)
        {
            return *currStatePtr;
        }
    }
    throw std::out_of_range(std::string("State name not found: ") + stateName);
}

const scxml_parser::state &dot_output::getFirstLeafState(const scxml_parser::state &state)
{
    //Find the first state which is child of the given state
    for(const auto& currStatePtr : sc.sc().states)
    {
        if(currStatePtr->parent)
        {
            if(currStatePtr->parent->id == state.id)
            {
                // found, try again with the found one
                return getFirstLeafState(*currStatePtr);
            }
        }
    }

    // if we are here, we have a leaf node
    return state;
}
